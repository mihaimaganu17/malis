expression  -> literal | unary | binary | grouping;
literal     -> NUMBER | STRING | "true" | "false" | "nil";
grouping    -> "(" expression ")";
unary       -> ( "-" | "!" ) expression;
binary      -> expression operator expression;
operator    -> "==" | "!=" | "<" | "<=" | ">" | ">=" | "+" | "-" | "*" | "/";

# Comma has the lowest precedence, so if we match that, we match everything
separator   -> ternary ((",") ternary)*;
# Ternary conditional operator
ternary     -> expression | expression ("?") expression (":") expression;
# Equality comes next after the `comma operator`
expression  -> equality;
equality    -> comparison (("!=" | "==") comparison)*;
comparison  -> term ((">" | ">=" | "<" | "<=") term)*;
term        -> factor (("-" | "+") factor)*;
# The rule recurses to match the left operand. Putting the recursive production on the left side
# and unary on the right makes the rule left-associative and unambiguous.
factor      -> factor ("/" | "*") unary
                | unary;
# Alternative to be used for the `factor` production rule to use a more optimal recursion
factor      -> unary (("/" | "*") unary)*;
# A unary expression starts with a unary operator followed by the operand. Since unary operators
# can next, `!!true` is valid
unary       -> ("!" | "-") unary | primary;
# Primary expression have the highest precedence. This means it represents all numbers, literals
# and grouping expressions
primary     -> NUMBER | STRING | "true" | "false" | "nil" | "(" expression ")";
